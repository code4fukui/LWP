<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width">
</head><title>LWP debugger</title>
<body>
<h1>LWP debugger</h1>
<button id=btn>Connect via Bluetooth(BLE)</button><br>

portnum1: <input id=portnum value=0>
<button id=btnsend>send</button><input id=num>
<input type=range min=-100 max=100 value=0 id=numr style="width:90vw;"><br>

portnum2: <input id=portnum2 value=1>
<button id=btnsend2>send</button><input id=num2>
<input type=range min=-100 max=100 value=0 id=numr2 style="width:90vw;"><br>

<!--
<button id=btnsend7>PORT req</button><input id=portreq1><input id=portreq2><br>
<button id=btnsend4>PORT mode req</button><input id=portmreq1><input id=portmreq2><input id=portmreq3><br>
-->
PORT input: <input id=portinp1 value=0><input id=portinp2 value=0><input id=portinp3 type=checkbox><br>

<button id=btnsend3>RGB(0-10)</button><input id=colr><br>
<!--
  <button id=btnsend3_2>RGB(R,G,B)</button><input id=rgb1><input id=rgb2><input id=rgb3><br>
-->

<button id=btnsend6>HUB off</button><br>
<div id=tbl></div>
<textarea id=tadata></textarea>

<hr>
Reference: <a href=https://lego.github.io/lego-ble-wireless-protocol-docs/>LEGO Wireless Protocol 3.0.00 Doc v3.0.00 r17 documentation</a><br>
<a href=https://github.com/code4fukui/LWP/>LWP src on GitHub</a><br>


<script type="module">
import { Base64 } from "https://js.sabae.cc/Base64.js";
import { sleep } from "https://js.sabae.cc/sleep.js";
import * as reqb from "./reqbuilder.js";
import { getDevID, getDevName } from "./types.js";
import { CSV } from "https://js.sabae.cc/CSV.js";

// https://lego.github.io/lego-ble-wireless-protocol-docs/
// https://googlechrome.github.io/samples/web-bluetooth/notifications.html

btn.onclick = async () => {
  const data = {};
  const showData = () => {
    tadata.value = JSON.stringify(data, null, 2);
    tbl.innerHTML = "";
    const getModes = (data) => {
      const ports = data?.ports;
      if (!ports) {
        return [];
      }
      const json = [];
      let n = 1;
      for (const portId in ports) {
        const port = ports[portId];
        const d = {
          port: portId,
          devname: port.devname,
          //n_mode: port.cntmode,
        };
        if (!port.modes) {
          json.push(d);
          continue;
        }
        for (let i = 0; i < port.modes.length; i++) {
          const mode = port.modes[i];
          const d2 = {};
          d2.idx = n++;
          Object.assign(d2, d);
          d2.mode = i;
          const names = ["name", "min", "max", "symbol", "input", "output", "value"];
          for (const name of names) {
            const v = mode[name];
            d2[name] = typeof v == "object" ? JSON.stringify(v) : v;
          }
          json.push(d2);
        }
      }
      return CSV.fromJSON(json);
    };
    const ar = getModes(data);
    if (ar.length > 0) {
      tbl.appendChild(CSV.makeTable(getModes(data)));
    }
  };

  const getPort = (portId) => {
    if (!data.ports) {
      data.ports = {};
    }
    if (!data.ports[portId]) {
      data.ports[portId] = {};
    }
    return data.ports[portId];
  };
  const getMode = (port, nmode) => {
    if (!port.modes) {
      port.modes = [];
    }
    if (!port.modes[nmode]) {
      port.modes[nmode] = {};
    }
    return port.modes[nmode];
  };

  const uuidService = "00001623-1212-efde-1623-785feabcd123"; // "c5f50001-8280-46da-89f4-6d8051e4aeef";
  const uuidCharacteristic = "00001624-1212-efde-1623-785feabcd123";
  //const manufacturerData = [{ companyIdentifier: 0xffff }];
  const device = await navigator.bluetooth.requestDevice({
    filters: [
      //{ name: "Technic Hub" },
      { services: [uuidService] }, // for all of LEGO series
      //{ manufacturerData },
    ],
    // acceptAllDevices: true,
    optionalServices: [uuidService],
  });
  console.log(device, device.name);
  device.addEventListener('advertisementreceived', (event) => {
    const b = Base64.decode(event.device.id);
    const sid = new TextDecoder().decode(b);
    console.log(sid);
    console.log('Advertisement received.');
    console.log('  Device Name: ' + event.device.name);
    console.log('  Device ID: ' + event.device.id, sid);
    console.log('  RSSI: ' + event.rssi);
    console.log('  TX Power: ' + event.txPower);
    console.log('  UUIDs: ' + event.uuids);
    //console.log(event);
    event.manufacturerData.forEach((valueDataView, key) => {
      console.log('Manufacturer', key, valueDataView);
    });
    event.serviceData.forEach((valueDataView, key) => {
      console.log('Service', key, valueDataView);
    });

    data.name = event.device.name;
    //data.id = sid;
    data.id = event.device.id;
    data.rssi = event.rssi;
    data.txPower = event.txPower;
    data.uuids = event.uuids;
    showData();
  });
  await device.watchAdvertisements();

  const server = await device.gatt.connect()
  console.log("server", server);
  //const services = await server.getPrimaryServices();
  //console.log(services);
  const service = await server.getPrimaryService(uuidService);
  console.log(service);
  const ch = await service.getCharacteristic(uuidCharacteristic);
  // Write without response, Notify
  console.log(ch);

  let autocollect = true;

  await ch.startNotifications();
  const parseUploadStream = (e) => {
    const v = new Uint8Array(event.target.value.buffer);
    // len, hubid(0), messagetype()
    // https://lego.github.io/lego-ble-wireless-protocol-docs/index.html#hub-attached-i-o
    // 5,  0, 4, 0, 0, disconnect A, messagetype(4=Hub Attached I/O)
    // 5,  0, 4, 1, 0, disconnect B
    // 15, 0, 4, 1, 1, 46, 0, 0, 16, 0, 0, 0, 16, 0, 0: connect B motor
    //           portid 1=B,
    //              attach=1, detach=0
    //                 0x002e ?? motor? List NOT guaranteed up to date! https://lego.github.io/lego-ble-wireless-protocol-docs/index.html#io-typ
    //                        hardware version
    //                                     software version

    /* Technic Hub https://lego.github.io/lego-ble-wireless-protocol-docs/index.html#hub-attached-i-o
    connected 0 0x2e - motor (not listed) :POWER(-100 100) PCT(%)
    connected 1 0x2e - motor (not listed) :POWER(-100 100)
    connected 50 0x17 - RGB Light :COL O(0 10)
    connected 59 0x15 - Current :CUR L(0 4095) mA
    connected 60 0x14 - Voltage :VLT L(0 4095) mV
    connected 61 0x3c - :TEMP(-900 900) DEG (ちょっと高め)
    connected 96 0x3c - :TEMP(-900 900) DEG (更にちょっと高め)
    connected 97 0x39 - :GRV(-32768 32768) mG, ACCELEROMETER ? https://github.com/nathankellenicki/node-poweredup/blob/master/src/hubs/technicmediumhub.ts
    connected 98 0x3a - :ROT(-28571.419921875 28571.419921875) DPS, GYRO_SENSOR ?
    connected 99 0x3b - :POS(min-max:-180-180) DEG, TILT_SENSOR ?
    connected 100 0x36 - :GEST(min-max:0-4)
    */
    const datalen = v[0];

    const buf2bin = (idx, len) => new Uint8Array(event.target.value.buffer, idx, len === undefined ? datalen - idx : len);
    const buf2s = (idx, len) => {
      const s = new TextDecoder().decode(buf2bin(idx, len));
      const n = s.indexOf("\u0000");
      return n >= 0 ? s.substring(0, n) : s;
    };
    const buf2hex = (idx, len) => {
      const b = buf2bin(idx, len);
      const s = [];
      for (const n of b) {
        s.push((n < 0x10 ? "0" : "") +  n.toString(16));
      }
      return s.join(":");
    };
    const buf2float = (idx, len) => {
      const b = new Uint8Array(len * 4);
      for (let i = 0; i < b.length; i++) {
        b[i] = v[i + idx];
      }
      return new Float32Array(b.buffer);
    };

    const hubid = v[1];
    const mestype = v[2];
    if (mestype == 1) {
      const prop = v[3];
      const op = v[4];
      if (prop == 1) {
        data.name = buf2s(5, datalen - 5);
      } else if (prop == 2) {
        data.hubbtn = v[5];
      } else if (prop == 3) {
        // firm ver int32
      } else if (prop == 4) {
        // hard ver int32
      } else if (prop == 5) {
        data.rssi = v[5];
      } else if (prop == 6) {
        data.battery = v[5];
      } else if (prop == 7) {
        data.batterytype = v[5];
      } else if (prop == 8) {
        data.manuname = buf2s(5, datalen - 5);
      } else if (prop == 9) {
        data.radiover = buf2s(5, datalen - 5);
      } else if (prop == 0xa) {
        data.lwpver = v[5] | (v[6] << 8);
      } else if (prop == 0xb) {
        data.system = v[5] >> 5;
        data.desc = v[5] & 31;
      } else if (prop == 0xc) {
        data.lastnet = v[5];
      } else if (prop == 0xd) {
        data.mac1 = buf2hex(5, datalen - 5);
      } else if (prop == 0xe) {
        data.mac2 = buf2hex(5, datalen - 5);
      } else if (prop == 0xf) {
        data.netfamily = v[5];
      } else {
        throw new Error("unknown prop: " + prop);
      }
      return;
    } else if (mestype == 4) {
      const portId = v[3];
      const port = getPort(portId);
      console.log(portId, port)
      const comtype = v[4];
      if (comtype == 0) { // disconnect
        console.log("disconnected", portId);
        data.ports[portId] = {};
        return;
      } else if (comtype == 1) {
        const devid = v[5] | (v[6] << 8);
        port.devid = getDevID(devid);
        port.devname = getDevName(devid);
        console.log("connected", portId, port.devid);
        return;
      }
    } else if (mestype == 5) { // RSSi
      const rssi = (new Int8Array(event.target.value.buffer))[3];
      console.log("RSSi", rssi);
      return;
    } else if (mestype == 0x43) { // 0x43 - port information
      const portId = v[3];
      const port = getPort(portId);
      const type = v[4];
      if (type == 1) {
        const output = !!(v[5] & 1);
        const input = !!(v[5] & 2);
        port.logicalcombi = !!(v[5] & 4);
        port.logicalsync = !!(v[5] & 8);
        port.cntmode = v[6];
        const inputmode = v[7] | (v[8] << 8);
        const outputmode = v[9] | (v[10] << 8);
        for (let i = 0; i < port.cntmode; i++) {
          const mode = getMode(port, i);
          mode.input = !!(inputmode & (1 << i));
          mode.output = !!(outputmode & (1 << i));
        }
        //console.log({ output, input, logicalcombi, logicalsync, cntmode, inputmode, outputmode });


        return;
      }
    } else if (mestype == 0x44) { // 0x44 - response of motor port request https://lego.github.io/lego-ble-wireless-protocol-docs/index.html#port-mode-information
      const portId = v[3];
      const port = getPort(portId);
      const nmode = v[4];
      const mode = getMode(port, nmode);
      const infotype = v[5]; // 0:NAME, 1:RAW, 2:PCT, 3:SI, 4:SYMBOL, 5:MAPPING, 0x80:VALUE FORMAT
      if (infotype == 0) {
        mode.name = buf2s(6);
        //console.log("info0", portId, mode, name);
        return;
      } else if (infotype == 1) {
        const f = buf2float(6, 2);
        mode.min = f[0];
        mode.max = f[1];
        //console.log("info1", portId, mode);
        return;
      } else if (infotype == 4) {
        mode.symbol = buf2s(6);
        //console.log("info5 Symbol", portId, mode, name);
        return;
      }
      console.log("infotype", infotype);
    } else if (mestype == 0x45) { // 0x45 port input
      const portId = v[3];
      const port = getPort(portId);
      const nmode = port.currentmode; // because can't get
      const mode = getMode(port, nmode);
      const n2i = (n) => n > 32767 ? n - 65536 : n;
      const b2i = (n) => n > 127 ? n - 256 : n;
      if (datalen == 5) {
        mode.value = b2i(v[4]);
        //console.log("port value", portId, n);
        return;
      } else if (datalen == 6) {
        mode.value = n2i(v[4] | (v[5] << 8));
        //console.log("port value", portId, n);
        return;
      } else if (datalen == 8) {
        mode.value = v[4] | (v[5] << 8) | (v[6] << 16) | (v[7] << 24);
        //console.log("port value", portId, n, "or float");
        return;
      } else if (datalen == 10) { // ACCELEROMETER, GYRO_SENSOR, TILT_SENSOR
        const x = n2i(v[4] | (v[5] << 8));
        const y = n2i(v[6] | (v[7] << 8));
        const z = n2i(v[8] | (v[9] << 8));
        mode.value = { x, y, z };
        //console.log("port value", portId, x, y, z);
        return;
      }
    } else if (mestype == 0x47) {
      const portId = v[3];
      const port = getPort(portId);
      const nmode = v[4];
      const mode = getMode(port, nmode);
      const delta = 0; // v[5] v[6] v[7] v[8]
      mode.notify = !!v[9];
      return;
    }
    throw new Error("unknown mestype: " + mestype.toString(16));
  };
  ch.addEventListener("characteristicvaluechanged", (e) => {
    parseUploadStream(e);
    showData();
  });

  const writePower = (n) => {
    const portId = portnum.value;
    ch.writeValueWithResponse(reqb.createPortOutputStartPower(portId, n));
  };
  btnsend.onclick = () => {
    writePower(num.value);
  };
  //
  for (let i = 1; i <= 0xf; i++) {
    await ch.writeValueWithResponse(reqb.createHubProperty(i));
  }
  //

  numr.onchange = () => writePower(numr.value);
  btnsend2.onclick = () => {
    // -15: center, -30
    ch.writeValueWithResponse(reqb.createGotoAbsolutePosition(portnum2.value, num2.value, 50, 50));
  };
  btnsend3.onclick = () => {
    ch.writeValueWithResponse(reqb.createSetColor(50, colr.value));
  };
  /*
  btnsend3_2.onclick = () => {
    ch.writeValueWithResponse(reqb.createSetRGB(50, rgb1.value, rgb2.value, rgb3.value));
  };
  */
  /*
  btnsend7.onclick = () => {
    ch.writeValueWithResponse(reqb.createPortInformationRequest(portreq1.value, portreq2.value));
  };
  btnsend4.onclick = () => {
    ch.writeValueWithResponse(reqb.createPortModeInformationRequest(portmreq1.value, portmreq2.value, portmreq3.value));
  };
  */
  portinp3.onchange = () => {
    const portId = portinp1.value;
    const nmode = portinp2.value;
    const port = getPort(portId);
    port.currentmode = nmode;
    ch.writeValueWithResponse(reqb.createPortInputFormatSetup(portId, nmode, portinp3.checked ? 1 : 0));
  };
  btnsend6.onclick = () => {
    const type = 1; // off
    ch.writeValueWithResponse(reqb.createHubActions(type));
  };

  // auto collect
  const collectAll = async () => {
    await sleep(2000);
    for (const portId in data.ports) {
      await ch.writeValueWithResponse(reqb.createPortInformationRequest(portId, 1));
    }
    await sleep(1000);
    for (const portId in data.ports) {
      const port = data.ports[portId];
      for (let i = 0; i < port.cntmode; i++) {
        await ch.writeValueWithResponse(reqb.createPortModeInformationRequest(portId, i, 0)); // name
        await ch.writeValueWithResponse(reqb.createPortModeInformationRequest(portId, i, 1)); // min/max
        await ch.writeValueWithResponse(reqb.createPortModeInformationRequest(portId, i, 4)); // symbol
      }      
    }
  };
  collectAll();
  
  /*
  // hub button checker
  setInterval(async () => {
    await ch.writeValueWithResponse(reqb.createHubProperty(2));
  }, 1000);
  */
};
</script>

<style>
table {
  border-collapse: collapse;
  margin-top: 1em;
}
th, td {
  border: 1px solid #222;
  padding: 0.1em 0.5em;
}
textarea {
  margin-top: 1em;
  width: 95vw;
  height: 30em;
}
</style>
